<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta charset="utf-8">
    <meta name="author" content="M E Leypold">
    <title>Type Tagging in C++ | Glitzersachen.de</title>
    
            <link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
      <link rel="canonical" href="http://www.glitzersachen.de/posts/techtipps/type-tagging-in-cxx.html">
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"></script>
    <![endif]-->
            <link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">

    





    
</head>
<body>
<!-- Menubar -->
<div class="navbar navbar-fixed-top" id="navbar">
    <div class="navbar-inner">
        <div class="container">

        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </a>

            <a class="brand" href="../../index.html">
            Glitzersachen.de
            </a>
            <!-- Everything you want hidden at 940px or less, place within here -->
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                <li>
<a href="../../archive.html">Archives</a>
                </li>
<li>
<a href="../../categories/index.html">Tags</a>
                </li>
<li>
<a href="../../teachswt.html">TeachSWT</a>
                </li>
<li>
<a href="../../rss.xml">RSS Feed</a>

                </li>
</ul>
                <ul class="nav pull-right">
                
                
		    <li><a href="../../about.html#impressum">Imprint/Impressum</a></li>
                    <li>
			<a href="type-tagging-in-cxx.md" id="sourcelink">Source</a>
		</li>
                </ul>
            </div>
        </div>
    </div>
</div>
<!-- End of Menubar -->
<div class="container-fluid" id="container-fluid">
    <!--Body content-->
    <div class="row-fluid">
    <div class="span2"></div>
    <div class="span8">
    
    <article class="postbox post-text">
    <div class="h-entry" itemscope="itemscope" itemtype="http://schema.org/Article">
    
    <h1 class="p-name" itemprop="headline name">Type Tagging in C++</h1>

    <hr>
    <small>
        Posted: <time class="published dt-published" datetime="2014-05-09T00:01:41+00:00" itemprop="datePublished">2014-05-09 00:01</time>
        

		
          |  
        More posts about 
    <span itemprop="keywords">
        <a class="tag p-category" href="../../categories/c.html"><span class="badge badge-info">c++</span></a>
        <a class="tag p-category" href="../../categories/disposable.html"><span class="badge badge-info">disposable</span></a>
        <a class="tag p-category" href="../../categories/tech-topic.html"><span class="badge badge-info">tech topic</span></a>
        <a class="tag p-category" href="../../categories/type-tagging.html"><span class="badge badge-info">type tagging</span></a>
    </span>


          |  
		
    </small>
    <hr>
    <div class="e-content" itemprop="articleBody text">
    <div>
<p><em>Type tagging</em> wraps invocation arguments in objects of a different type to select a
different instance of an overloaded construct and thus a different processing policy for
the argument. This can be done at no cost at runtime and with a reasonably nice syntax. I'll show use cases and demonstrate a sample implementation.</p>
<!-- TEASER_END -->

<h2>Introduction</h2>
<p><em>Type tagging</em> is, what I've been calling the technique of wrapping constructor or method
arguments in a shallow wrapper object to select a different instance of an overloaded
construct and thus a different processing policy for the argument.</p>
<p>Here is an example: Assume you want to construct an object of class <em>SomeThing</em> from a
vector of <em>Foo</em>. A rather typical approach would be:</p>
<div class="codehilite"><pre><span class="nx">vector</span><span class="o">&lt;</span><span class="nb">Foo</span><span class="o">&gt;</span> <span class="nx">v</span><span class="p">;</span>
<span class="nx">...</span> <span class="nx">build</span> <span class="nx">vector</span> <span class="nx">v</span><span class="p">;</span>
<span class="nx">SomeThing</span> <span class="nb">s</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
</pre></div>


<p>In the general case, <em>SomeThing</em> would just copy data from <em>v</em> to
build up its inner initial state. This might not be as efficient as
desired - copying might be expensive. If, in example, <code>SomeThing</code> is
in itself using a <code>vector&lt;Foo&gt;</code> to store its internal state the
possibility opens up, to use <em>std::swap</em> to take over the content of
<em>v</em> by <strong>moving</strong> it into the object, instead of <strong>copying</strong>.  <em>v</em>
would be changed by this operation, so this is only possible if the
content of <em>v</em> is not needed any more after object construction,
i.e. if <em>v</em> was only a helper object. In practice this case occurs
frequently for objects with non trivial inner structure. But it cannot
be the only mode of construction. It depends on the client code using
<em>SomeThing</em> if it wants to continue using v. One might want to
construct a series of related objects, reusing the content of <em>v</em>:</p>
<div class="codehilite"><pre><span class="p">...</span> <span class="n">build</span> <span class="n">vector</span> <span class="n">v</span><span class="p">;</span>
<span class="n">SomeThing</span> <span class="nf">s1</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">...</span> <span class="n">modify</span> <span class="n">vector</span> <span class="n">v</span><span class="p">;</span>
<span class="n">SomeThing</span> <span class="nf">s2</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre></div>


<p>Generally I cannot (and should not want) to restrict the user of my
class to one mode of construction (copying vs. moving). Rather I want
to support both modes with sensible defaults following the principle
of least surprise:</p>
<p><em>Type tagging</em> will allow to do that by marking the argument in the
 following way:</p>
<div class="codehilite"><pre><span class="nx">vector</span><span class="o">&lt;</span><span class="nb">Foo</span><span class="o">&gt;</span> <span class="nx">v</span><span class="p">;</span>
<span class="nx">...</span> <span class="nx">build</span> <span class="nx">vector</span> <span class="nx">v</span><span class="p">;</span>
<span class="nx">SomeThing</span> <span class="nb">s</span><span class="p">(</span> <span class="nx">disposable</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">);</span>
</pre></div>


<p>will tell the constructor that it can move the content of <em>v</em> (if it
supports this), whereas</p>
<div class="codehilite"><pre><span class="nx">vector</span><span class="o">&lt;</span><span class="nb">Foo</span><span class="o">&gt;</span> <span class="nx">v</span><span class="p">;</span>
<span class="nx">...</span> <span class="nx">build</span> <span class="nx">vector</span> <span class="nx">v</span><span class="p">;</span>
<span class="nx">SomeThing</span> <span class="nb">s</span><span class="p">(</span> <span class="nx">v</span> <span class="p">);</span>
</pre></div>


<p>still copies the content of <em>v</em> (which is the safe default). It is
also desirable that, if <em>SomeThing</em> doesn't know about about type
tagging conventions, that the copying constructor is used
instead. This is indeed possible as we will see.</p>
<p>The following article presents a sample implementation of type tagging
(that is, the "operator" <em>disposable</em>) and explains how it works. I'll
discuss alternatives to the <em>type tagging</em> approach at some other
time.</p>
<p>At this point you might already suspect a relationship to <em>C++ 11</em>
rvalue references and <em>std::move</em> . You're not wrong: One might think
about <em>rvalue references</em> as compiler supplied (that is: automatic)
type tagging. I'll elaborate on this in a follow up article. But the
idea I'm going to present here will work even with <em>C++ 98</em> which does
no have rvalue references and can be extended to other areas of
application (beyond selecting copying/moving constructors).</p>
<h2>Implementation</h2>
<h3>Goals</h3>
<p>To summarize: If we write</p>
<div class="codehilite"><pre><span class="n">SomeThing</span> <span class="nf">s</span><span class="p">(</span> <span class="n">v</span> <span class="p">);</span>
</pre></div>


<p>we want one thing to happen (namely <em>v</em> being copied and not
modified), whereas if we write</p>
<div class="codehilite"><pre><span class="n">SomeThing</span> <span class="nf">s</span><span class="p">(</span> <span class="n">disposable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">);</span>
</pre></div>


<p>we want another thing to happen (namely the content of <em>v</em> being
reused for the sake of efficiency, accepting that <em>v</em> is being
modified in the process).</p>
<p>This can be effected, of course, by implementing two different
versions of the constructor <em>SomeThing</em> which take different Types:</p>
<div class="codehilite"><pre><span class="n">SomeThing</span><span class="p">(</span><span class="k">const</span> <span class="n">Multiples</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>


<p>and</p>
<div class="codehilite"><pre><span class="nx">SomeThing</span><span class="p">(</span><span class="nx">DisposableRef</span><span class="o">&lt;</span><span class="nx">Multiples</span><span class="o">&gt;</span> <span class="nx">dm</span><span class="p">)</span> <span class="p">{</span> <span class="nx">...</span> <span class="p">}</span>
</pre></div>


<p>(For my implementation example I assume that the parameter passed to
the constructor is an object of class <em>Multiples</em>. You'll find the
complete implementation in the <a href="../../listings/type-tagging-in-cxx/example1_type-tagging.cc.html">listing</a>).</p>
<p>The job of <code>disposable()</code> is just to wrap a class of type
<em>DisposableRef<multiples></multiples></em> around a <code>Multiples&amp;</code> to provide the type
that will make the compiler select the alternate constructor.</p>
<h3>The Wrapper Class</h3>
<p>The wrapper class <em>DisposableRef<multiples></multiples></em> is easily defined as a
template:</p>
<div class="codehilite"><pre><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">DisposableRef</span> <span class="p">{</span> 
<span class="nl">public:</span>
  <span class="kr">inline</span> <span class="n">DisposableRef</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">inner</span><span class="p">)</span> <span class="o">:</span> <span class="n">inner</span><span class="p">(</span><span class="n">inner</span><span class="p">){</span> <span class="p">};</span>
  <span class="kr">inline</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">()</span>        <span class="p">{</span> <span class="k">return</span> <span class="n">inner</span> <span class="p">;</span> <span class="p">}</span>
<span class="nl">private:</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">inner</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The constructor simply stores the reference, the method
<code>DisposableRef::ref()</code> is required to retrieve the reference again
(e.g. in the alternate constructor).  </p>
<p><em>Disposable</em> can be implemented as:</p>
<div class="codehilite"><pre><span class="nx">template</span><span class="o">&lt;</span><span class="nb">typename</span> <span class="nb">T</span><span class="o">&gt;</span>
<span class="k">inline</span> <span class="nx">DisposableRef</span><span class="o">&lt;</span><span class="nb">T</span><span class="o">&gt;</span> <span class="nx">disposable</span><span class="p">(</span><span class="nb">T</span><span class="o">&amp;</span> <span class="nx">inner</span><span class="p">){</span> 
  <span class="k">return</span> <span class="nx">DisposableRef</span><span class="o">&lt;</span><span class="nb">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">inner</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><em>Disposable</em> is only a wrapper function to avoid having to specify
the type of the argument all the time. <code>DisposableRef(m)</code> does not
work, one would have to write <code>DisposableRef&lt;Multiples&gt;(m)</code> which
would be too cumbersome. A template function on the other side can be
invoked without a type argument to the template: <code>disposable(m)</code>.</p>
<p>Note,</p>
<ul>
<li>that <em>DisposableRef</em> has the reference as only member,</li>
<li>that all the methods are non virtual, and can therefore be inlined,</li>
<li>that they only pass the reference into the object or return the
  reference from the single member.</li>
</ul>
<p>This means, there is hope that, with a reasonable compiler, this will
compile to the same code as if the raw pointer is being passed
around. </p>
<p><em>DisposableRef</em> Construction and <code>disposable()</code> ideally could be
removed at compile time, that is: compile to <em>no-ops</em>, since they take
an address and return the very same address. Ideally they would only
supply type information that is used at run time to select a different
operation, but the address passed around and the way it is passed
around, should always be the same.</p>
<p>After all, the type is something that exists only in the compiler and
the binary representation of <code>T&amp;</code> and <code>Disposable&lt;T&gt;</code> is probably the
same.</p>
<p>This has not been demonstrated so far in this article and there is no
guarantee in the standard, but it can be strongly expected. A full
demonstration, though, will have to be subject of another follow up
article.</p>
<h3>Testing</h3>
<p>Let's test drive my implementation, First we fill in the
implementation of <em>SomeThing</em>:</p>
<div class="codehilite"><pre><span class="nb">class</span> <span class="nx">SomeThing</span> <span class="p">{</span>
<span class="k">public</span><span class="p">:</span>
  <span class="nx">SomeThing</span><span class="p">(</span><span class="nx">const</span> <span class="nx">Multiples</span><span class="o">&amp;</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">"Something: Received NON-disposable argument - need to copy"</span> <span class="o">&lt;&lt;</span> <span class="nx">endl</span><span class="p">;</span>
    <span class="nx">this</span><span class="o">-&gt;</span><span class="nx">m</span> <span class="o">=</span>  <span class="nx">m</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">SomeThing</span><span class="p">(</span><span class="nx">DisposableRef</span><span class="o">&lt;</span><span class="nx">Multiples</span><span class="o">&gt;</span> <span class="nx">dm</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">"Something: Received disposable argument - can swap/move."</span> <span class="o">&lt;&lt;</span> <span class="nx">endl</span><span class="p">;</span>
    <span class="nx">swap</span><span class="p">(</span><span class="nx">this</span><span class="o">-&gt;</span><span class="nx">m</span><span class="p">,</span> <span class="nx">dm.ref</span><span class="p">());</span>
  <span class="p">}</span>
<span class="k">private</span><span class="p">:</span>
  <span class="nx">Multiples</span> <span class="nx">m</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now, if we execute the following statements (assuming an output
operator has been defined for <em>Multiples</em>)</p>
<div class="codehilite"><pre><span class="n">Multiples</span> <span class="nf">m</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">;</span>

<span class="n">SomeThing</span> <span class="nf">st2</span><span class="p">(</span> <span class="n">m</span> <span class="p">);</span>                <span class="c1">// 1st call</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">;</span>

<span class="n">SomeThing</span> <span class="nf">st1</span><span class="p">(</span> <span class="n">disposable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">);</span>    <span class="c1">// 2nd call</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">;</span>
</pre></div>


<p>then we get the following:</p>
<div class="codehilite"><pre><span class="n">Multiples</span> <span class="err">@</span> <span class="mh">0xbf93b39c</span> <span class="n">counting</span> <span class="mi">3</span><span class="o">:</span>
 <span class="mi">7</span> <span class="mi">14</span> <span class="mf">21.</span>
<span class="nl">Something:</span> <span class="n">Received</span> <span class="n">NON</span><span class="o">-</span><span class="n">disposable</span> <span class="n">argument</span> <span class="o">-</span> <span class="n">need</span> <span class="n">to</span> <span class="n">copy</span>
<span class="n">Multiples</span> <span class="err">@</span> <span class="mh">0xbf93b39c</span> <span class="n">counting</span> <span class="mi">3</span><span class="o">:</span>
 <span class="mi">7</span> <span class="mi">14</span> <span class="mf">21.</span>
<span class="nl">Something:</span> <span class="n">Received</span> <span class="n">disposable</span> <span class="n">argument</span> <span class="o">-</span> <span class="n">can</span> <span class="n">swap</span><span class="o">/</span><span class="n">move</span><span class="p">.</span>
<span class="n">Multiples</span> <span class="err">@</span> <span class="mh">0xbf93b39c</span> <span class="n">counting</span> <span class="mi">0</span><span class="o">:</span>
<span class="p">.</span>
</pre></div>


<p>This is exactly as desired: The first call selects the first
constructor which copies the data from the argument, leaving the
argument unmodified. The second call selects the second constructor
which swaps the internal state of the argument into the object
instead.</p>
<h3>More Motivation</h3>
<p>There is one aspect noteworthy in the method demonstrated so far: The
decision if the argument can be destroyed, is left to the caller
(instead of the designer of the class <em>SomeThing</em>). This is as it
should be: The class designer cannot decide which method (<em>swap</em> or
<em>copy</em>) is best for building the internal class state. Only providing
a "copying" constructor would close the door on any optimization in
this regard. Only providing a "swapping" constructor would lead to
undue surprises when invoked as <em>SomeThing(m)</em>.</p>
<p>The effect I'm achieving so far with the demonstrated implementation
is</p>
<ul>
<li>invoking the copying constructor by default and</li>
<li>invoking the swapping constructor only if this is marked so at the
  place of invocation,</li>
</ul>
<p>This is exactly the right way to go.</p>
<p>There is one issue left, though: Exactly because the user of
<em>SomeThing</em> rather than the designer is providing the policy
information implicit in the markup with <code>disposable()</code>, he would have
to check for every class, if it provides a swapping
constructor. Imagine a class <em>SomeThingElse</em> which does only provide
the copying constructor as given above. <code>SomeThingElse se1(
disposable(m) )</code> would end in an error message by the compiler:</p>
<div class="codehilite"><pre><span class="nx">example1_type</span><span class="na">-tagging.cc</span><span class="p">:</span><span class="mi">85</span><span class="p">:</span> <span class="nb">error</span><span class="p">:</span> <span class="nx">no</span> <span class="nx">matching</span> <span class="nx">function</span> <span class="nb">for</span> <span class="nb">call</span> <span class="k">to</span> <span class="err">‘</span><span class="nx">SomeThingElse</span><span class="p">::</span><span class="nl">SomeThingElse</span><span class="p">(</span><span class="nx">DisposableRef</span><span class="o">&lt;</span><span class="nx">Multiples</span><span class="o">&gt;</span><span class="p">)</span><span class="err">’</span>
<span class="nx">example1_type</span><span class="na">-tagging.cc</span><span class="p">:</span><span class="mi">62</span><span class="p">:</span> <span class="nx">note</span><span class="p">:</span> <span class="nx">candidates</span> <span class="nx">are</span><span class="p">:</span> <span class="nx">SomeThingElse</span><span class="p">::</span><span class="nl">SomeThingElse</span><span class="p">(</span><span class="nx">const</span> <span class="nx">Multiples</span><span class="o">&amp;</span><span class="p">)</span>
<span class="nx">example1_type</span><span class="na">-tagging.cc</span><span class="p">:</span><span class="mi">60</span><span class="p">:</span> <span class="nx">note</span><span class="p">:</span>                 <span class="nx">SomeThingElse</span><span class="p">::</span><span class="nl">SomeThingElse</span><span class="p">(</span><span class="nx">const</span> <span class="nx">SomeThingElse</span><span class="o">&amp;</span><span class="p">)</span>
</pre></div>


<p>But in the end it would be very much desirable to be able to use
<em>disposable()</em> even in cases where there is no swapping constructor,
and profit from a swapping constructor if one is introduced in perhaps
a later version of <em>SomeThingElse</em>.</p>
<p>Fortunately this feature is easily added to <em>DisposableRef</em> as
demonstrated in the next section, so a user of a class can always
write <code>SomeThingElse se1( disposable(m) )</code> without having to know if a
swapping constructor exists. This way he can use <em>disposable()</em> just
to mark up, that he is not interested in the content of the argument
<em>m</em> any more and that construction <em>might</em> be optimized by swapping
out state from <em>m</em>.</p>
<p>The question if this is <em>actually</em> done is now removed from
implementing the data flow. It can instead become a part of later
optimization process or part of the dialog between the class designer
and somebody (maybe even some third party) identifying performance
bottle necks and optimizing the application. The data processing
logic, at that later point is not affected and the code at the point
of invocation needs not to be changed.</p>
<p>Maybe even more important: The call to <em>disposable()</em> could then be
generated by a template without regard to the constructors provided by
some template class argument.</p>
<h3>Fallbacks</h3>
<p>The desired fallback can be implemented by adding a conversion
operator from <code>DisposableRef&lt;T&gt;</code> to <code>T&amp;</code> to <code>DisposableRef&lt;T&gt;</code>:</p>
<div class="codehilite"><pre><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">DisposableRef</span> <span class="p">{</span> 
<span class="nl">public:</span>
  <span class="kr">inline</span> <span class="n">operator</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">inner</span> <span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>


<p>Now in the following code fragment </p>
<div class="codehilite"><pre><span class="n">Multiples</span> <span class="nf">m2</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m2</span><span class="p">;</span>

<span class="n">SomeThingElse</span> <span class="nf">se2</span><span class="p">(</span> <span class="n">m2</span> <span class="p">);</span>              <span class="c1">// Call 1</span>
<span class="n">SomeThingElse</span> <span class="nf">se1</span><span class="p">(</span> <span class="n">disposable</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span> <span class="p">);</span>  <span class="c1">// Call 2</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m2</span><span class="p">;</span>
</pre></div>


<p><em>Call 2</em> will compile, but will select the same (and only) constructor
 as <em>call 1</em>:</p>
<div class="codehilite"><pre><span class="n">Multiples</span> <span class="err">@</span> <span class="mh">0xbfca62f8</span> <span class="n">counting</span> <span class="mi">5</span><span class="o">:</span>
 <span class="mi">5</span> <span class="mi">10</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mf">25.</span>
<span class="nl">SomethingElse:</span> <span class="n">Treating</span> <span class="n">as</span> <span class="n">NON</span><span class="o">-</span><span class="n">disposable</span> <span class="n">argument</span> <span class="o">-</span> <span class="n">need</span> <span class="n">to</span> <span class="n">copy</span>
<span class="nl">SomethingElse:</span> <span class="n">Treating</span> <span class="n">as</span> <span class="n">NON</span><span class="o">-</span><span class="n">disposable</span> <span class="n">argument</span> <span class="o">-</span> <span class="n">need</span> <span class="n">to</span> <span class="n">copy</span>
<span class="n">Multiples</span> <span class="err">@</span> <span class="mh">0xbfca62f8</span> <span class="n">counting</span> <span class="mi">5</span><span class="o">:</span>
 <span class="mi">5</span> <span class="mi">10</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mf">25.</span>
</pre></div>


<p>Xou can see: The argument <em>m2</em> will not be modified.</p>
<p>Note, that constructor selection for <em>SomeThing</em> still works as
demonstrated above, since, when resolving the constructor overloading,
the compiler will</p>
<ul>
<li>first look for a constructor with exactly the type signature of the
  arguments at the invocation,</li>
<li>and only then look for suitable conversions which would allow an
  alternative constructor to be invoked.</li>
</ul>
<p>Since it finds <code>SomeThing(DisposableRef&lt;Multiples&gt; dm)</code> first, the
possibility of conversion will never be considered,</p>
<h2>Coda</h2>
<p>What I've demonstrated so far is a - in my opinion rather nice -
syntax, to direct the system to handle an argument to a constructor in
a way different from the default. But I've intentionally omitted to
delve into some points:</p>
<ul>
<li>
<p>What are the alternatives to using type tagging as demonstrated?
  What about using a flag as a parameter? What about using a special
  builder syntax instead of passing a complex data structure? What
  about using <em>const</em> to control copying vs. swapping? What about
  <em>std::copy</em>?</p>
</li>
<li>
<p>I've only asserted that I consider it rather probable that type
  tagging comes without extra runtime cost. This still needs to be
  demonstrated.</p>
</li>
<li>
<p><em>std::move</em> looks rather related to type tagging. Indeed it is the
  <em>same idea -- rvalue references</em> are compiler supplied type tagging
  <em>(if you, like me, insist to understand rvalue references</em> based on
  <em>the type tagging idea) and </em>std:move<em> like </em>disposable<em> just
  </em>converts the type at compile time.</p>
</li>
<li>
<p>Type tagging can be used for more than selecting different
  constructors.</p>
</li>
</ul>
<p>All these points will be subject of further articles in this mini
series.</p>
<h2>Resources</h2>
<ul>
<li>Demo implementation: <a href="../../listings/type-tagging-in-cxx/example1_type-tagging.cc.html">listings/ type-tagging-in-cxx/ example1_type-tagging.cc</a>
</li>
</ul>
</div>
    </div>
    </div>
    
        <ul class="pager">
            <li class="previous">
                <a href="../announcements/now-on-nikola.html" rel="prev">← Previous post</a>
            </li>
        </ul>

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="glitzersachen-de",
            disqus_url="http://www.glitzersachen.de/posts/techtipps/type-tagging-in-cxx.html",
        disqus_title="Type Tagging in C++",
        disqus_identifier="cache/posts/techtipps/type-tagging-in-cxx.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="http://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


    

    </article>

    </div>
    </div>
    <!--End of body content-->
</div>
<div class="footerbox">
    Contents © 2014         <a href="../../about.html#impressum">M E Leypold</a> - Powered by         <a href="http://getnikola.com" rel="nofollow">Nikola</a>         
</div>

            <script src="../../assets/js/all-nocdn.js" type="text/javascript"></script>


    

    <script type="text/javascript">jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});
    $(window).on('hashchange', function(){
        if (location.hash && $(location.hash)[0]) {
            $('body').animate({scrollTop: $(location.hash).offset().top - $('#navbar').outerHeight(true)*1.2 }, 1);
        }
    });
    $(document).ready(function(){$(window).trigger('hashchange')});
    </script>
    
    
</body>
</html>
